사용자 공간 섀도우 스택은 사용자 공간에서 실행되는 프로세스의 스택을 보호하기 위한 메커니즘

섀도우 스택은 실제 스택과 동일한 크기와 구조를 갖는 가상 스택

섀도우 스택은 실제 스택의 모든 쓰기 작업을 모니터링하고, 악의적인 코드가 스택을 조작하는 것을 방지



프로세스가 시작되면 커널은 실제 스택과 동일한 크기와 구조를 갖는 섀도우 스택을 생성

프로세스가 스택에 데이터를 쓰면 커널은 실제 스택과 섀도우 스택에 동일한 데이터를 씁

프로세스가 스택에서 데이터를 읽으면 커널은 실제 스택에서 데이터를 읽고, 섀도우 스택의 데이터와 비교


스택 오버플로 공격 방지: 섀도우 스택을 사용하면 악의적인 코드가 스택을 오버플로우하여 메모리를 덮어쓰는 것을 방지

ROP 공격 방지: ROP 공격은 악의적인 코드가 스택에 저장된 라이브러리 함수의 주소를 사용하여 시스템을 제어하는 공격

섀도우 스택을 사용하면 악의적인 코드가 스택에 저장된 라이브러리 함수의 주소를 조작하는 것을 방지

XSS 공격 방지: XSS 공격은 악의적인 코드가 웹 브라우저의 스택을 조작하여 사용자의 브라우저를 악의적인 웹 사이트로 리디렉션하는 공격

단점

성능 저하: 섀도우 스택을 사용하면 스택에 쓰기 작업을 할 때마다 커널이 실제 스택과 섀도우 스택에 동일한 데이터를 써야 하므로 성능이 저하

구현 복잡성: 섀도우 스택을 구현하려면 커널과 사용자 공간의 코드가 모두 수정되어야 하므로 구현이 복잡할 수 있음


-----


사용자 공간 섀도우 스택은 Linux의 비교적 새로운 기능입니다. 지원은 6.6에만 추가되었으며 x86 아키텍처로 제한

섀도우 스택은 반환 주소만 포함하는 현재 호출 스택의 복사본(이는 CPU에 의해 유지)

섀도우 스택이 활성화되면 모든 함수 호출로 인해 반환 주소가 일반 스택과 섀도우 스택 모두에 푸시

함수가 반환될 때마다 일반 스택의 반환 주소는 섀도우 스택의 복사본과 비교


두 개가 일치하지 않으면 프로세서가 트랩되고 (일반적으로) 영향을 받는 프로세스가 종료

ROP(반환 지향 프로그래밍) 공격을 포함하여 오버런 스택 기반 변수를 기반으로 하는 공격에 대한 방어를 제공하기 위한 것

섀도우 스택과 작동하지 않는 코드가 있으므로 해당 기능을 기본적으로 활성화할 수 없음

prctl() 호출을 통해 섀도우 스택을 생성하고 활성화할 수 있음

지난 10월 Mark Brown(arm64 섀도우 스택 구현 작업 중)은 이러한 방식으로 새로운 기능을 추가할 수 있도록 설계된 비교적 새로운 시스템 호출인 clone3()에 해당 제어 기능을 추가하는 패치 시리즈를 게시

몇 가지 논의 끝에 사용자 공간이 섀도우 스택을 정확하게 배치할 수 있도록 허용하는 것이 유용할 수 있지만 해당 기능이 압도적으로 필요하지는 않다는 결론

스레드 생성 시 사용자 공간이 섀도우 스택의 크기에 영향을 미치도록 허용하는 것이 왜 필요한지 궁금

섀도우 스택을 일반 스택과 동일한 크기로 할당하는 현재 정책으로 인해 발생할 수 있는 섀도우 스택의 과잉 할당을 방지

스레드가 큰(일반) 스택으로 생성되어 거기에 큰 데이터 배열을 저장할 수 있는 경우 섀도우 스택도 그만큼 커지고 해당 공간의 거의 전부가 됩 - 낭비

단일 스레드의 경우 이러한 낭비는 허용될 수 있지만 스레드 수가 많은 애플리케이션에서는 메모리 손실이 커질 수 있음

동일한 크기의 섀도우 스택이 너무 작은 경우도 있습니다. sigaltstack() 시스템 호출을 사용하면 스레드가 신호 전달에 사용할 대체 스택을 설정할 수 있습니다. 그러나 스레드가 대체 스택으로 전환되더라도 계속해서 동일한 섀도우 스택을 사용합니다. 스레드가 일반 스택을 모두 소모한 다음 대체 스택의 깊은 호출 체인을 사용하여 신호(스택 공간 부족으로 인해 발생할 수도 있음)를 처리하는 경우 섀도우 스택이 오버플로될 수 있습니다.

clone3()에서 적절한 크기의 섀도우 스택을 생성하면 새 스레드가 섀도우 스택 적용 범위 없이 실행되지 않음

섀도우 스택을 지원하는 아키텍처가 단 하나뿐

면 결국 섀도우 스택을 구현하는 모든 아키텍처의 새 스레드에 제공되는 섀도우 스택의 크기를 제어하는 것이 가능해질 것


----

새도우 스택을 사용하면 하드웨어는 일반적으로 사용자 공간에서 쓸 수 없는 분기 명령에 대한 반환 주소만 포함하는 추가 스택을 유지하고 모든 반환이 기록된 주소로 이루어지도록 보장

이는 ROP 공격으로부터 어느 정도 보호를 제공하고 호출 스택을 더 쉽게 수집할 수 있게 해

이러한 섀도우 스택은 사용자 공간 프로세스의 주소 공간에 할당


섀도우 스택용 API는 현재 새로 생성된 스레드에 대한 섀도우 스택 할당을 관리하기 위한 유연성을 사용자 공간에 제공하지 않습니다. 대신 커널은 기능이 활성화된 스레드가 생성될 때마다 일반 스택과 동일한 크기의 새 섀도우 스택을 할당합니다. 이러한 방식으로 할당된 스택은 스레드가 종료되거나 스레드에 대해 섀도우 스택이 비활성화될 때 커널에 의해 해제됩니다. 이러한 유연성 및 제어 부족은 이상적이지 않습니다. 대부분의 경우 섀도우 스택은 초과 할당되고 암시적 할당 및 할당 해제는 다른 인터페이스와 일치하지 않습니다. 내가 알 수 있는 한 인터페이스는 주로 clone3()이 구현되기 전부터 섀도우 스택 패치가 개발 중이었기 때문에 이런 방식으로 수행되었습니다.

