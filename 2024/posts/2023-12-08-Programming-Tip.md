---
layout: 'index'
view: 'post'
permalink: '/posts/2023/12/08/Programming-Tip.html'
opengraph:
    site:
        name: 'ProjectedBy/Sub'
        url: '/'
date: '2023/12/08 10:52:00'
title: 'Programming Tip'
description: ""
category: 'ProgrammingTip'
tags: ['Programming', 'Tip']
---

## Bard: Gemini Pro 로 업그레이드

[Experiment updates](https://bard.google.com/updates)
<date>2023.12.06</date>
<author>Bard</author>
<url>https://bard.google.com/updates</url>

오늘부터 Bard 사상 최대 규모의 업그레이드인 Gemini Pro를 Bard에 도입

이해와 요약, 추론, 코딩 및 계획과 같은 작업을 훨씬 더 효과적으로 수행할 수 있도록 Bard의 Gemini Pro를 특별히 조정

텍스트 기반 프롬프트를 위해 Gemini Pro와 함께 Bard를 사용해 볼 수 있으며 다른 양식도 곧 지원될 예정

처음에는 170개 이상의 국가 및 지역에서 영어로 제공될 예정이며, 가까운 시일 내에 유럽을 비롯한 더 많은 언어와 장소에 제공될 예정

## 받은편지함에 이미 있는 피싱 위협을 확인

[See the phishing threats that are already in your inbox](https://www.cloudflare.com/lp/phishing-retro-scan/)
<date>...</date>
<author>cloudflare</author>
<url>https://www.cloudflare.com/lp/phishing-retro-scan/</url>

받은편지함에 이미 있는 피싱 위협을 확인

Microsoft 365는 원치 않는 이메일을 제한하는 필수 제어 기능을 제공하지만, 표적화되고 회피적인 피싱 공격은 기본 제공 보안을 우회할 수 있는 경우가 많음

Cloudflare의 피싱 역스캔을 사용하면 기존 방어를 우회한 악성 이메일을 포함하여 이미 사용자에게 도달한 활성 위협을 즉시 식별 가능

무료로 재검사를 시작하고 몇 분 만에 피싱 보고서를 받아 Microsoft 365 받은 편지함에서 검색된 위협 유형에 대한 평가를 받을 수 있음

사용자 정의 보고서는 악의적인 메시지, 의심스러운 메시지, 스푸핑 메시지, 스팸 메시지, 대량 메시지는 물론 조직에서 가장 표적이 된 개인에 대한 자세한 분석을 생성

## 무선 충전 표준 Qi2

[무선 충전 기술에 대한 거의 모든 것 - 최신 무선 충전 표준 Qi2는 뭐가 다를까?](https://the-edit.co.kr/61305)
<date>2023. 12. 06</date>
<author>
    <a href="https://the-edit.co.kr/author/hosub_choi">최호섭</a>
</author>
<url>https://the-edit.co.kr/61305</url>


자석을 사용하는 애플의 액세서리 규격 맥세이프

현재 가장 많이 쓰는, 일반적으로 ‘무선 충전’이라고 부르는 기술은 ‘Qi 방식을 기본으로 함

‘치’라고 부르는데 한자로 ‘기운 기(氣)’자를 중국어로 읽은 이름

국제무선충전표준협회(WPC, wireless power consortium)가 2008년에 만든 무선 충전의 표준 규격

지금 쓰는 거의 모든 스마트폰은 바로 이 Qi 방식의 ‘자기 유도’를 이용

자기 유도는 코일과 자성이 전기를 만들고 다른 곳으로 흘러가는 원리를 이용하는 기술

- 동그랗게 말린 코일에 전기를 흘리면 자기장이 일어남
- 그리고 가까이에 코일을 대면 자기장이 흘러감
- 이를 다시 전기로 되돌리면 케이블 없이도 무선으로 전기를 흘려보낼 수 있는 것
- 전자기 유도라고 부르는 물리 현상을 이용
- 코일끼리 밀리미터 단위로 가까이 맞붙어야 하기 때문에 보통은 충전 거치대에 올려두는 방식을 많이 쓰임

애초 이것보다 더 나은 기술로 고민됐던 경쟁 기술은 자기 공명 방식

기본적으로 자기장을 이용하는 것은 비슷한데 자기 공진 방식은 특정 주파수의 자기장을 만들어서 주변에 쏘고, 충전할 기기는 해당 주파수에만 반응하는 수신부를 통해 전자기를 흡수

충전기에 기기를 올려 두지 않아도 근처에만 있으면 저절로 기기가 충전

하지만 아무 기기나 충전할 수 있기 때문에 이 자기 공명 무선 충전은 충전을 허용하는 암호화가 필요하고, 전자파에 대한 일상의 우려도 있었습니다. 충전 신호는 곧 전자파이고, 그 강도에 따라 사람에게 영향이 있을지도 모른다는 걱정

물론 전자파의 유해성은 과학적으로 검증되지는 않았지만 어쨌든 많은 사람들이 예민하게 반응하는 요소

자기 유도 방식은 훨씬 간단

기술적으로는 아주 가까운 곳만 충전된다는 것이 약점일 수 있지만 제품 측면에서는 제품을 충전기에 맞붙이는 것 자체가 충전에 대한 확실한 의사 전달 방법

전력의 손실도 줄일 수 있음

Qi 외에 ‘파워매트(PMA)’ 방식도 있음

영리단체였던 Qi의 세계무선충전협회와 기술 그 자체를 발전시키고자 했던 비영리단체 PMA는 각자의 방법으로 기술을 키워 나감

PMA는 여러 제조사들이 협회에 참여하면서 기술을 키워나간 Qi에 비해 상대적으로 단말기가 부족하다는 단점

PMA는 자기 공명 방식 기술을 개발하고 있는 A4WP(Alliance for Wireless Power)과 기술을 통합하기로 하면서 잠깐 쉬어가는 중

현재의 무선 충전은 Qi로 완전히 자리를 잡았다고 볼 수 있음

무선 충전을 하면서 묘하게 신경 쓰이는 것이 바로 기기를 두는 위치

기기와 무선 충전기에는 전자기를 만들어서 주고받는 코일이 있고, 두 코일은 가까이 맞붙어야 함

중심이 정확히 맞아야 충전 효율이 좋아짐

맥세이프 규격을 지원하는 벨킨의 충전기

맥 세이프는 단순히 보면 Qi 방식 무선 충전 접접에 강력한 자석을 더한 것

정확한 충전 위치를 잡아주고, 충전 거치대만이 아니라 케이블을 통해서 기기 뒷편에 붙일 수도 있음

자력이 세서 자석식 거치대로 쓸 수 있을 만큼 단단하게 붙기도 함

iOS17에 도입된 아이폰의 스탠바이 모드

애플은 iOS17에서 스탠바이 모드를 도입하면서 충전중에 간단한 정보를 전달하는 탁상 시계로 쓸 수 있게 만들어 버림

그냥 자석만 붙은 것은 아니고 내부에 간단한 정보를 전송할 수 있는 통신 모듈이 붙기 때문에 맥 세이프 충전기를 알아채거나, 케이스의 색깔을 표시하기도 하고, 심지어 연결된 액세서리의 펌웨어 업데이트도 할 수 있음

맥세이프는 당연히 애플이 만든 규격이고, 애플의 브랜드지만 그렇다고 아주 폐쇄적이지는 않음

무선 충전 기술을 만든 WPC도 맥세이프의 자석을 받아들이기로 함

Qi가 무선 충전의 가능성을 현실화했다면 Qi2는 현실의 문제를 다시 기술로 반영한다는 의미를 가짐

맥세이프와 같은 자석, 그리고 15W 이상의 고속 충전

지금 나와 있는 맥세이프와 거의 같고, 근래의 Qi 충전 기기들이 대부분 갖고 있는 특성

자석은 사실상 Qi2의 가장 중요한 부분

고속 무선 충전이 매끄럽게 이뤄지려면 코일과 코일이 정확히 맞닿아야 함

전기 에너지의 손실은 대부분 열 에너지로 전환되기 때문에 손실을 줄이면 발열도 줄어들 수 있음

열이 줄어들면 배터리는 다시 충전 속도를 높일 수 있기 때문에 충전에 대한 적절한 선순환

‘무선으로 된다’는 것만으로도 기술은 가치가 있지만 여기에 자석을 붙이고, 소프트웨어를 더하면서 기술이 경험으로 더 큰 가치를 갖게 되는 게 무선 충전에서 보이는 기술 흐름

근처에만 있어도 충전할 수 있는 자기 공명 방식도 여전히 개발중, 그 활용 범위도 스마트폰을 넘어 PC부터 전기차까지 고려되고 있음

충전에 대한 고민이 사라지는 것이 결국 무선 충전 기술의 가야 할 길

## SQLite, JSONB 지원 기능 도입

[SQLite, JSONB 지원 기능 도입](https://news.hada.io/topic?id=12213)
<date>...</date>
<author>
    <a href="https://news.hada.io/user?id=neo">neo</a>
</author>
<url>https://news.hada.io/topic?id=12213</url>

SQLite의 기존 JSON 함수를 재작성. 사용패턴에 따라 몇배까지 더 빠르게 실행됨

원래 JSON 함수는 3단계로 동작

- JSON을 C코드가 쉽게 처리가능한 내부용 바이너리 포맷으로 파싱
- 요청한 작업 수행. 특정 필드를 찾거나 JSON을 수정하거나 하는 등
- 작업이 JSON을 변경했다면, 내부 바이너리 포맷을 RFC-8279 JSON 문자열로 바꿔서 출력 또는 저장

2단계 말고 1과 3은 오버헤드임

SQLite는 많은 포인터를 포함하는 내부 바이너리 형태의 JSON을 사용했음.

C 프로그램에 잘 맞지만 시리얼라이즈가 어려움

JSONB 재작성을 통해서 이 JSON의 내부 바이너리 표현을 SQL BLOB으로 읽거나 쓸 수 있는 연속된 바이트 배열로 변경

이렇게 하면 내부에서 사용하는 JSON의 표현을 JSON 텍스트 대신 데이터베이스에 저장할 수 있으므로 1단계와 3단계의 오버헤드를 제거할 수 있음
변경된 것

모든 기존 기능은 그대로 유지. 새로운 기능만 추가

이제 JSON 텍스트를 입력으로 받아들이는 모든 JSON 함수는 동일한 매개변수에 대해 JSONB 바이너리 콘텐츠도 받아들임

함수가 텍스트를 가져올지 바이너리 데이터를 가져올지 알려줄 필요가 없음. 함수가 스스로 알아서 판단

이제 JSON을 출력하는 JSON 함수는 두 가지 버전으로 제공

- 기존의 "json_" 함수는 이전과 동일하게 작동
- 텍스트 JSON이 아닌 JSONB를 반환하는 "jsonb_" 함수가 있어 일반 처리에서 3단계가 생략됨

애플리케이션을 변경하지 않으면 속도가 약간(1%) 빨라지기는 하지만 모든 것이 기존과 동일하게 계속 작동

그러나 애플리케이션을 수정하여 텍스트 JSON 대신 JSONB를 저장하기 시작하면 적어도 JSON 집약적인 작업의 경우 3배의 성능 향상을 볼 수 있음

또한 JSONB는 대부분의 경우 텍스트 JSON보다 약간 더 작기 때문에(약 5% 또는 10% 더 작음) JSON을 많이 사용하는 경우 데이터베이스 크기가 약간 줄어드는 것을 볼 수도 있음

## Book: The Linux Kernel Module Programming Guide

[The Linux Kernel Module Programming Guide](https://sysprog21.github.io/lkmpg)
<date>...</date>
<author>
    Peter Jay Salzman, Michael Burian, Ori Pomerantz, Bob Mottram, Jim Huang
</author>
<url>https://sysprog21.github.io/lkmpg</url>

The Linux Kernel Module Programming Guide

## Frequency Counter in TypeScript

[Frequency Counter in TypeScript](https://naviava.hashnode.dev/frequency-counter-in-typescript)
<date>Dec 7, 2023</date>
<author>
    <a href="https://hashnode.com/@naviava">Navin Avadhani</a>
</author>
<url>https://naviava.hashnode.dev/frequency-counter-in-typescript</url>

빈도 카운트 알고리즘

데이터 내의 패턴을 비교하고 분석하는 문제를 해결하는 데 사용되는 일반적인 기술

이는 두 개의 데이터 세트, 문자열 또는 배열을 비교하고 요소의 빈도가 동일한지 확인해야 하는 시나리오에서 특히 유용

빈도 계산 이해: 빈도 카운터 접근 방식에서는 객체(또는 TypeScript의 Map)를 사용하여 입력 데이터에 있는 각 개별 요소의 빈도를 계산하는 것이 아이디어, 객체나 맵의 키는 고유한 요소를 나타내고, 값은 발생 횟수를 나타냄

```ts
function createFrequencyCounter(arr: any[]): Record<string, number> {
    const frequencyCounter: Record<string, number> = {};

    for (const element of arr) {
      /* 
        If the element is not in the frequencyCounter,
        add it with a count of 1. Otherwise, increment the count.
      */
      frequencyCounter[element] = (frequencyCounter[element] || 0) + 1;
    }

    return frequencyCounter;
}
```

주파수 계산의 이점

- Efficiency: 주파수 카운터 접근 방식은 특히 대규모 데이터 세트를 처리할 때 중첩 루프나 기타 무차별 방식보다 더 효율적인 경우가 많음
- Readability: 문제를 더 작고 관리 가능한 단계로 나누어 코드의 가독성을 높임
- Versatility: 빈도 계산은 문자열, 배열 또는 반복 가능한 컬렉션과 같은 다양한 유형의 데이터에 적용될 수 있음

데이터 세트 내의 패턴을 비교하고 분석하는 효율적인 방법을 제공하므로 데이터 구조와 알고리즘을 다루는 모든 TypeScript 개발자의 툴킷에 필수적인 기술

## UX 디자인 원리 과제 - 좋은/안좋은 UX 사례

[UX 디자인 원리 과제 - 좋은/안좋은 UX 사례](https://www.inflearn.com/questions/1092791/ux-%EB%94%94%EC%9E%90%EC%9D%B8-%EC%9B%90%EB%A6%AC-%EA%B3%BC%EC%A0%9C-%EC%A2%8B%EC%9D%80-%EC%95%88%EC%A2%8B%EC%9D%80-ux-%EC%82%AC%EB%A1%80)
<date>23.12.05 14:33</date>
<author></author>
<url>https://www.inflearn.com/questions/1092791/ux-%EB%94%94%EC%9E%90%EC%9D%B8-%EC%9B%90%EB%A6%AC-%EA%B3%BC%EC%A0%9C-%EC%A2%8B%EC%9D%80-%EC%95%88%EC%A2%8B%EC%9D%80-ux-%EC%82%AC%EB%A1%80</url>

좋은 사례

Gmail PC 버전 카테고리별 전체 이메일 선택 기능:

왼쪽 상단 전체 이메일 체크 박스 옆에 작은 드롭다운 화살표를 배치함으로써 단순히 전체 이메일이 아닌 카테고리별 (read/unread/starred/unstarred) 전체 이메일을 선택 할 수 있다는 것을 사용자가 직관적으로 이해하게끔 되어있는데, 이는 행동 유도성의 원리에 부합하는 좋은 UX 사례라고 생각

안 좋은 사례

카카오 웹툰 어플리케이션:

일반적인 웹툰 독자들은 요일별로 정리 및 나열된 페이지에 익숙한데, 어느 시점부터 카카오 웹툰 어플은 가장 첫 화면에 장르별 웹툰을 배치했고 하단 메뉴에서 '시간표'를 클릭해야 일반적으로 익숙한 요일별 웹툰을 볼 수 있습니다. 10년 이상된 웹툰 독자로서 저는 해당 UI가 아직도 익숙하지 않아 원하는 웹툰을 찾기 위해 헤매는 경우가 종종 있습니다. 이는 일관성의 원리의 기준에서 안 좋은 UX 사례라고 생각됩니다.

## 리튬 배터리 삼성SDS, 항공운송 인증 획득

[리튬 배터리, 비행기 탄다…삼성SDS, 항공운송 인증 획득](https://www.thelec.kr/news/articleView.html?idxno=24519)
<date>2023.12.04 09:23</date>
<author>윤상호 기자</author>
<url>https://www.thelec.kr/news/articleView.html?idxno=24519</url>

삼성SDS가 리튬 배터리 항공운송 사업에 나섬

삼성SDS는 국제항공운송협회(IATA) ‘CEIV 리튬 배터리(Center of Excellence for Independent Validators Lithium Batteries) 항공운송 인증’을 취득했다고 4일 밝힘

CEIV 리튬 배터리 인증은 글로벌 표준 인증

삼성SDS는 물류 플랫폼 ‘첼로스퀘어’에서 리튬 배터리 물류 사업을 본격화할 계획


## 고(Go) 언어의 장단점 9가지

[속도와 단순함의 미덕 · · · 고(Go) 언어의 장단점 9가지](https://www.ciokorea.com/news/316362)
<date>...</date>
<author>Serdar Yegulalp</author>
<url>https://www.ciokorea.com/news/316362</url>

작고 간소한 고 언어 

- 고는 쉽게 배울 수 있고 다루기 편하며 다른 개발자가 읽기 쉬운 언어를 목표로 함
- 고는 특히 C++와 같은 언어와 비교해 기능이 많지는 않음
- 구문 측면에서는 C와 비슷하므로 오랜 기간 C를 사용해 온 개발자라면 비교적 쉽게 배울 수 있음
- 고의 여러 기능, 특히 동시성 및 함수형 프로그래밍 기능은 얼랭(Erlang)과 같은 언어와 더 비슷
- 고는 온갖 종류의 크로스 플랫폼 엔터프라이즈 애플리케이션을 구축하고 유지하기 위한 C와 유사한 언어
- 자바와도 많은 공통점을 갖고 있음
- 파이썬과는 유사점보다 차이점이 훨씬 더 크긴 함
- 동적 형식 지정 인터프리트 언어처럼 느껴지는 빠른 정적 형식 지정 컴파일 언어
- 규모가 큰 고 프로그램도 컴파일에는 몇 초밖에 걸리지 않음
- 고에서는 C 스타일의 include 파일 및 라이브러리에 따르는 오버헤드를 대부분 피할 수 있음

고 언어의 강점 

- 강점 1. 편리함 

    - 동시성과 스레드 동작을 위한 고루틴처럼 언어 자체에 내장된 경우도 있음
    - 고의 http 패키지와 같이 고 표준 라이브러리 패키지로 제공되는 부가적인 기능
    - 고는 파이썬과 마찬가지로 가비지 수집을 포함한 자동 메모리 관리 기능을 제공
    - 고 코드는 파이썬과 같은 스크립팅 언어와 달리 실행 속도가 빠른 네이티브 바이너리로 컴파일
    - C 또는 C++와 달리 고의 컴파일 속도는 매우 빨라서 고로 작업하다 보면 컴파일 언어보다는 스크립팅 언어에 가깝게 느껴짐
    - 고 빌드 시스템은 다른 컴파일 언어에 비해 덜 복잡

- 강점 2. 빠른 속도 

    - 고 바이너리의 실행 속도는 C 바이너리에 비하면 느리지만 그 차이가 크지는 않아서 대부분의 애플리케이션에서 무시해도 될 정도
    - 성능은 대부분의 작업에서 C에 필적
    - 자바스크립트, 파이썬, 루비 등 개발 속도로 유명한 다른 언어와 비교하면 대체로 훨씬 더 빠름

- 강점 3. 이식성 

    - 고 툴체인으로 생성된 실행 파일은 기본적인 외부 종속성 없이 독립적으로 작동할 수 있음
    - 고 툴체인은 다양한 운영체제 및 하드웨어 플랫폼용으로 제공
    - 이러한 툴체인을 사용해 여러 플랫폼에 걸쳐 바이너리를 컴파일할 수 있음

- 강점 4. 상호운용성 

    - 고는 모든 기능을 기반 시스템에 대한 접근성을 희생하지 않고 제공
    - 고 프로그램은 외부 C 라이브러리와 통신하거나 네이티브 시스템을 호출할 수 있음(도커에서 고는 저수준 리눅스 함수, 컨트롤 그룹(cgroups) 및 네임스페이스와 상호작용해 컨테이너 동작을 구현한)

- 강점 5. 광범위한 지원 

    - 고 툴체인은 리눅스, 맥OS 또는 윈도우 바이너리나 도커 컨테이너로 무료로 사용 가능
    
### 고 언어가 적합한 분야

- 분야 1. 클라우드 네이티브 개발 

    - 고의 동시성과 네트워킹 특성, 높은 수준의 이식성은 클라우드 네이티브 앱을 구축하는 데 적합

- 분야 2. 분산 네트워크 서비스 

    - 네트워크 애플리케이션의 성패는 동시성에 달려 있는데, 고루틴과 채널 등 고의 네이티브 동시성 기능이 이 부분에서 강점

- 분야 3. 유틸리티 및 독립형 툴 

    - 고 프로그램은 최소한의 외부 종속성을 가진 바이너리로 컴파일
    - 시작 시간이 빠르고 즉시 패키징해 재배포할 수 있으므로 유틸리티나 다른 툴을 만드는 데 적합
    - 텔레포트는 소스에서 컴파일하거나 사전 빌드된 바이너리를 다운로드하는 방법으로 빠르고 쉽게 서버에 배포할 수 있음
 
### 고 언어의 제약

- 제약 1. 생략된 언어 기능이 많음 

    - 고는 작고 이해하기 쉬운 언어에 중점을 두고 설계
    - 일부 기능은 의도적으로 생략
    - 제네릭 함수의 부재
    
- 제약 2. 바이너리 크기가 클 수 있음 

    - 고의 또 다른 잠재적인 단점은 생성된 바이너리의 크기
    - 기본적으로 고 바이너리는 정적으로 컴파일(런타임에 필요한 모든 요소가 바이너리 이미지에 포함) -  빌드 및 배포 프로세스를 간단하게 해주지만 그 대가로 “Hello, world!”를 출력하는 바이너리의 크기가 64비트 윈도우 기준 약 1.5MB에 이름
    - 압축이나 디버그 정보를 제거하는 방법으로 고 바이너리 크기를 줄이는 것도 가능

- 제약 3. 가비지 수집에서 많은 리소스 소비 

    - 가비지 수집을 위해 얼마간의 처리 오버헤드가 필요
    - 고는 설계상 수동 메모리 관리 기능을 제공하지 않음
    - 고의 가비지 수집은 엔터프라이즈 애플리케이션에서 발생하는 메모리 부하에 잘 대응하지 못한다는 비판

- 제약 4. GUI 구축을 위한 표준 툴킷의 부재 

장기적인 유지 관리가 가능한 확장성 있는 인프라를 더 쉽게 개발할 수 있는 기반이 되는 클라우드에서 고 언어의 미래는 확실
