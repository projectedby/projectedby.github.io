---
layout: 'index'
view: 'post'
permalink: '/posts/2023/12/19/Linux-Review.html'
opengraph:
    site:
        name: 'ProjectedBy/Sub'
        url: '/'
date: '2023/12/19 16:48:00'
title: 'Linux Review'
description: ""
category: 'LinuxReview'
tags: ['Linux', 'Review']
---

## A Rust implementation of Android's Binder
By Jonathan Corbet
November 30, 2023

https://lore.kernel.org/rust-for-linux/20231101-rust-binder-v1-0-08ba9197f637@google.com/

우리는 일반적으로 재작성(저녁 식사에 늦게 만드는 불쾌하고 불편한 일)을 지지하지 않습니다. 그렇다면 바인더를 다시 작성하는 이유는 무엇입니까?

안드로이드에서 바인더는 각각 독립된 프로세서들을 연결해 주는 역할을 하는데, 이것은 RUST로 재작성하는 이유에 대한 논의 내용입니다.

1. 복잡성: 수많은 오류 시나리오를 처리해야 하며 13개의 서로 다른 잠금, 7개의 참조 카운터 및 원자 변수를 결합/중첩하면서도 모든 작업을 최대한 빠르고 효율적으로 수행해야 하는데, 사소한 성능 저하가 일어나면 사용자 환경 또한 민감하게 저하될 수 있는데, 이런 작업을 하기에는 C로 구현된 현재의 코드가 너무 복잡하다.

2. 기술부채: 천줄이 넘는 함수에 오류가 발생하기 쉬운 오류 처리 등으로 인하여 혼란스러운 구조가 발생할 있다.

3. 보안: Android에서 샌드박스에 실행되는 (프로그램이 보호된 영역에서 동작해 시스템이 부정하게 조작되는 것을 막아주는 환경) 프로그램들도 이 바인더에 직접 접근할 수 있다.

죽, Binder 를 계속 발전시키고, 보안문제, 기술부채를 해결하는 것을 방해하는 것은 높은 복잡성이고, 이 복잡성을 줄이기 위해서 Rust 로 바인더를 구현하기로 결정하였습니다.

- 참조 계산, 잠금, 범위 확인과 관련된 실수를 방지
- 오류 처리의 복잡성을 줄이는 데 많은 도움 - 소멸자와 같은 기능을 사용하여 보다 단순화된 오류 처리를 허용
- 다양한 구조체와 포인터의 소유권 의미를 쉽게 구현 가능 - 바인더 드라이버에는 복잡한 소유권 의미를 갖는 다양한 개체가 존재하고, 일부 포인터는 참조 카운트를 소유하고, 일부 포인터는 독점 소유권을 가지며, 일부 포인터는 객체를 참조만 하고 다른 방식으로 활성 상태로 유지
- 프로그래머의 손에서 객체 수명 관리의 복잡성이 사라지고 사용 후의 위험이 줄듦

RUST 로 재작성하는 코드 구조는 기존 디자인에서 신중하게 고려된 많은 생각들이 반영, 코드 상태, 구조, 가독성, 견고성, 보안, 유지 관리 가능성 및 확장성을 향상시키는 것을 목표합니다.


- Rust 바인더는 Android 오픈소스 프로젝트에서 Binder의 정확성을 검증하는 모든 테스트를 통과했습니다. (장치를 부팅하고 다양한 앱과 기능을 문제 없이 실행할 수 있습니다.)

- 기능 패리티의 경우 Rust 바인더는 현재 일부 디버깅 기능을 제외하고 C 바인더가 지원하는 모든 기능을 구현

- 성능

- 벤치마크에서 C 바인더와 유사한 성능을 가지고 있음을 발견
- Rust 바인더가 트랜잭션 규모가 매우 큰 경우를 제외한 모든 테스트 사례에서 경쟁력이 있다는 것을 알 수 있음



https://lore.kernel.org/rust-for-linux/20231101-rust-binder-v1-0-08ba9197f637@google.com/



